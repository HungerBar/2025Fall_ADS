
# Project 5: Three Partition - 代码与算法说明

本文件由AI生成

## 1. 项目概览 (Overview)

本文件夹包含了针对 **3-Partition Problem** 的三种不同算法实现，以及配套的结果验证器。所有代码均采用 C++ 编写（如果不使用 STL，请参考代码中的特定注释，当前版本为了文件读写方便使用了基础库，核心逻辑符合 No STL 思想）。

### 文件清单

* **`dfs.cpp`**: **深度优先搜索 (DFS)**。这是精确算法，使用了强力剪枝。最适合处理 $N$ 较小的情况（如 $N \le 60$）。

* **`dp.cpp`**: **动态规划 (DP)**。这是精确算法，属于伪多项式时间复杂度。适合处理 $N$ 较大但数值总和较小的情况。

* **`sa.cpp`**: **模拟退火 (Simulated Annealing)**。这是启发式算法（近似解）。适合处理大规模数据（如 $N=1000$）或 Bonus 部分（K划分）。

* **`check.cpp`**: 结果验证器（Checker），用于判断 `output.txt` 是否正确。注意：对于`no`输出，暂时无法判断，均认为正确。

## 2. 算法原理与分析 (写 Report 参考)

### A. 深度优先搜索 (DFS) - `dfs.cpp`

* **核心逻辑**: 递归地尝试将每个数字放入桶 1、桶 2 或桶 3。

* **关键剪枝 (Pruning)** - **Report 重点**:

  1. **降序排序 (Sort Descending)**: 优先处理大数。大数灵活性差，能更快填满桶或触发容量溢出，从而更快回溯（Fail-Fast）。

  2. **等效性剪枝 (Symmetry Breaking)**: 这是最核心的优化。如果当前桶是空的（Sum=0），且我们尝试放入当前数字失败了，**则不需要尝试后续的空桶**。因为空桶在数学上是完全等价的，在第一个空桶失败意味着在所有空桶都会失败。

* **复杂度**: 最坏情况 $O(3^N)$，但因为剪枝，实际运行极快。

### B. 动态规划 (DP) - `dp.cpp`

* **核心逻辑**: 这是一个多维 **0/1 背包问题** 的变种。

* **状态定义**: `dp[i][j]` 是一个布尔值，表示是否能从前 $k$ 个物品中选出一些填满桶 1 到和为 $i$，同时填满桶 2 到和为 $j$。（桶 3 的状态是隐含的）。

* **路径还原**: 使用了一个三维数组 `path[k][i][j]` 来记录第 $k$ 个物品被放进了哪个桶，以便最后输出具体方案。

* **复杂度**:

  * 时间: $O(N \cdot Target^2)$

  * 空间: $O(N \cdot Target^2)$

  * **分析**: 这是 **伪多项式时间 (Pseudo-polynomial time)**。如果输入的数值很大（例如 $10^9$），算法会爆内存或超时；但如果数值有界，则是多项式时间。

### C. 模拟退火 (Simulated Annealing) - `sa.cpp`

* **核心逻辑**: 物理学启发的随机算法。

  1. **初始化**: 随机将数字分配到 3 个桶。

  2. **能量函数 (Cost)**: 计算当前桶的不平衡度（各桶与 Target 的差值绝对值之和）。目标是 Energy = 0。

  3. **扰动**: 随机 **移动 (Move)** 一个数或 **交换 (Swap)** 两个数。

  4. **Metropolis 准则**: 如果新状态更好，直接接受；如果更差，以概率 $P = \exp(\Delta E / T)$ 接受（为了跳出局部最优）。

* **重启策略**: 如果一次退火没找到解，且时间未到限制（0.9秒），会自动重置并再次搜索。

* **用途**: 用于解决 **Bonus** 问题（代码中修改 `K` 即可）和 **大规模数据**。

## 3. 编译与运行指南 (How to Run)

我们使用文件输入输出（File I/O）：程序从 `input.txt` 读取，写入 `output.txt`。

### 第一步：编译所有文件

请在终端/命令行中运行：

**Windows:**

```

g++ dfs.cpp -o dfs.exe -O2
g++ dp.cpp -o dp.exe -O2
g++ sa.cpp -o sa.exe -O2
g++ check.cpp -o check.exe

```

**Mac / Linux:**

```

g++ dfs.cpp -o dfs -O2
g++ dp.cpp -o dp -O2
g++ sa.cpp -o sa -O2
g++ check.cpp -o check

```

*(注意: `-O2` 参数用于开启优化，对 DFS 速度提升很大)*

### 第二步：运行流程

1. **生成数据**
   手动生成小样例，用程序生成大样例

2. **运行求解器 (三选一)**:
程序会自动读取 `input.txt` 并生成 `output.txt`。

```

./dfs      \# 运行 DFS

# 或

./dp       \# 运行 DP

# 或

./sa       \# 运行 模拟退火

```

3. **验证结果**:
验证器会检查 `input.txt` 和 `output.txt`，判断是否正确。

```

./check

```

* 如果输出 `Correct`，说明结果正确。

* 如果输出 `Wrong`，请检查 `output.txt` 内容。

## 4. 实验建议 (For Report Graphs)

为了画 Report 里的性能对比图：

1. 修改 `gen.cpp` 中的 `TEST_N` (比如改成 10, 20, 30, ... 60)。

2. 分别运行 `dfs` 和 `dp`。

3. 记录运行时间（可以使用系统命令 `time ./dfs` 或者手动掐表）。

4. **预期结论**:

* $N$ 较小时，DFS 极快。

* $N$ 变大时，DFS 时间波动很大（取决于数据难易），DP 时间增长较平滑（取决于 Sum 大小）。

* $N$ 极大时（如 1000），只有 `sa` (模拟退火) 能跑出结果。
